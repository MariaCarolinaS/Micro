AULA 1:
O que são sistemas embarcados?
São sistemas completos e independentes construídos para um único propósito de aplicação que realizam um conjunto de tarefas 
pré definidas com requisitos específicos.

O que são sistemas microprocesssados?
São sistemas que são realizados por circuitos integrados, geralmente constituídos por uma ULA, uma unidade de controle e registradores.
Sistema capaz de realizar um conjunto de instruções pré determinadas e geralmente e utiilizado com CPU de computadores.

Apresente aplicações de sistemas embarcados: (a) para a indústria automotiva; (b) para eletrodomésticos; (c) para automação industrial.
(A) Airbags, sistemas de segurança.
(B) Máquinas de lavar, termostatos.
(C) Analisadores Industriais, robótica Industrial, controlador single loop/mult loop.

Cite arquiteturas possíveis e as diferenças entre elas.
Von Neumann: sua execução de instruções é sequencial e seu barramento de instruções e dados é único.
Harvard: há um maior paralelismo e seus barramentos para instruções e dados são separados.

Por que usamos o MSP430 na disciplina, ao invés de outro microcontrolador?
O MSP430 possui processador de 16bits, multiplicação por hardware, aplicações de baixo consumo de energia, registradores de 16 bits,
grande número de periféricos analógicos, é rápido, sua IDE é mais completa. Fatores que o fazem ser melhor que os demais
microcontroladores.


AULA 2:
Quais as diferenças entre os barramentos de dados e de endereços?
O barramento de dados transmite dados entre as unidades e o barramento de endereços é usado para selecionar a origem ou destino de
sinais transmitidos.

Quais são as diferenças entre as memórias RAM e ROM?
RAM é uma memória volátil, que pode ser lida e escrita enquanto a ROM é uma memória não volátil, sua escrita é mais lenta e é somente 
uma memória para ser lida, o seu conteúdo é escrito durante sua fabricação.

Considere o código abaixo:

#include <stdio.h>
int main(void)
{
int i;
printf("Insira um número inteiro: ");
scanf("%d", &i);
if(i%2)
printf("%d eh impar.\n");
else
printf("%d eh par.\n");
return 0;
}
Para este código, responda: (a) A variável i é armazenada na memória RAM ou ROM? Por quê? (b) O programa compilado a partir deste código
é armazenado na memória RAM ou ROM? Por quê?
(A) RAM, pois i é uma variável global que não necessita ser mantida posteriormente, somente precisa ser armazenada em um dos 
registradores durante a execução do programa.
(B) RAM, pois o programa não realiza a função de salvar na ROM, desse modo, todos os dados são salvos de maneira volátil.

Quais são as diferenças, vantagens e desvantagens das arquiteturas Harvard e Von Neumann?
Von Neumann: sua execução de instruções é sequencial e seu barramento de instruções e dados é único.
Harvard: há um maior paralelismo e seus barramentos para instruções e dados são separados.

Considere a variável inteira i, armazenando o valor 0x8051ABCD. Se i é armazenada na memória a partir do endereço 0x0200,
como ficam este byte e os seguintes, considerando que a memória é: (a) Little-endian; (b) Big-endian.
(A) 51
(B) AB

Sabendo que o processador do MSP430 tem registradores de 16 bits, como ele soma duas variáveis de 32 bits?
Ele utiliza duas posições nos registradores para cada uma das variáveis.

AULA 3:

AULA 4:
1. Traduza as seguintes linhas em C para a linguagem assembly do MSP430. 
Utilize somente as seguintes instruções: mov.w, add.w e sub.w. 
(A) f = 0: mov.w #00, R4

(B) g++: add.w #01, R5

(C) h--: sub.w #01, R6

(D) i += 2: add.w #02, R7

(E) j -= 2: sub.w #02, R8

2. Traduza as seguintes linhas em C para a linguagem assembly do MSP430.
Utilize somente as seguintes instruções: mov.w, add.w, sub.w, clr.w, dec.w, decd.w, inc.w e incd.w.
(A) f = 0: clr.w R4

(B) g++: inc.w R5

(C) h--: dec.w R6

(D) i += 2: incd.w R7

(E) j -= 2: decd.w R8

3. Traduza as seguintes linhas em C para a linguagem assembly do MSP430.
Utilize somente as seguintes instruções: mov.w, add.w, sub.w, clr.w, dec.w, decd.w, inc.w e incd.w. 
(A) f *= 2: add.w R4 R4

(B) g *= 3: mov.w R5 R11
            add.w R5 R11
            add.w R11 R5
      
(C) h *= 4: mov.w R7 R11
            add.w R7 R11
            add.w R7 R11
            add.w R11 R7

(D) A[2] = A[1] + A[0]: mov.w 2(R9) 4(R9) 
                        add.w 0(R9) 4(R9)

(E) A[3] = 2*f - 4*h:  mov.w R4 6(R9)
                       add.w R4 6(R9)
                       sub.w R6 6(R9) 
                       sub.w R6 6(R9) 
                       sub.w R6 6(R9) 
                       sub.w R6 6(R9)

(F) A[3] = 2*(f - 2*h): mov.w R4 R11
                        sub.w R6 R11
                        sub.w R6 R11
                        mov.w R11 6(R9)
                        add.w R11 6(R9)


